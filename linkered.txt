#Install linkerd:
curl --proto '=https' --tlsv1.2 -sSfL https://run.linkerd.io/install-edge | sh

export PATH=$HOME/.linkerd2/bin:$PATH

#Create alias:
echo "alias l='linkerd'" >> ~/.bashrc
source ~/.bashrc

l check --pre

#Create Gateway API before installing linkerd:
kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.2.0/standard-install.yaml

#Install linkerd:
linkerd install --crds | kubectl apply -f -
linkerd install | kubectl apply -f -
l check

#We need to open linkerd dashbord via viz extenion:
#Check th eviz extension is installed:
l viz check
#Failed so install viz extension
#has to to do this:
linkerd viz install | kubectl apply -f -


Open linkerd dashboard:
linkerd viz dashboard
#Visit: http://localhost:50750/

#if not do:
l dashboard


#Install demo app:
curl --proto '=https' --tlsv1.2 -sSfL https://run.linkerd.io/emojivoto.yml \
  | kubectl apply -f -


#Post forward:
kubectl -n emojivoto port-forward svc/web-svc 8080:80

#Visit:
http://localhost:8080

#mesh it:

kubectl get -n emojivoto deploy -o yaml \
  | linkerd inject - \
  | kubectl apply -f -

#The above command get the deployment in enojivoto namespace and annotates the pods in spec section and apply it back, This anootation instructs
#Linkerd to injetc proxies data plance in the pods.


#Check proxies:
linkerd -n emojivoto check --proxy

###############################
#Linkerd on Flask-db##########
##############################

kubectl get -n db deploy -o yaml \
  | linkerd inject --opaque-ports=54 \
  | kubectl apply -f -
  
  
 kubectl get -n dblin sts -o yaml \
  | linkerd inject - \
  | kubectl apply -f -
  
 
#check proxies:
linkerd -n emojivoto check --proxy

#visit the flask app:
k get nodes -o wide
#get the IP

http://172.18.0.2:30008/
#why 30008? dont remember

#FOr ingress:
http://flask.postgres.linkerd:8484/
why 8484? because mapped in kind-cluser.yaml 8484->80



###################
#DEbugging commands
###################

kubectl logs debug -n dblin -c linkerd-proxy | grep mydb-service
k logs postgres-0 -n dblin -c linkerd-proxy
linkerd viz edges -n dblin deployment


#See the tCP connetcion on postgre pod:
linkerd diagnostics proxy-metrics pod/postgres-0 -n dblin | grep 5432
<<<<<<<<<<
inbound_tcp_authz_allow_total{target_addr="10.244.0.34:5432",target_ip="10.244.0.34",target_port="5432",srv_group="",srv_kind="default",srv_name="all-unauthenticated",srv_port="5432",authz_group="",authz_kind="default",authz_name="all-unauthenticated",tls="true",client_id="default.dblin.serviceaccount.identity.linkerd.cluster.local"} 3
>>>>>>>>>>>>
#This shows 3 connetcion

#Scale down the flask-app to one pod:
k scale deploy flask-app --replicas=1 -n dblin

#Now run in flask ingress some numbers to get the data and check again the connection from flask app:
linkerd diagnostics proxy-metrics deploy/flask-app -n dblin | grep 5432

<<<<<<<<<<<<<<<<
tcp_open_total{direction="outbound",peer="src",target_addr="10.96.158.10:5432",target_ip="10.96.158.10",target_port="5432",tls="no_identity",no_tls_reason="loopback"} 9
tcp_open_total{direction="outbound",peer="dst",authority="mydb-service.dblin.svc.cluster.local:5432",target_addr="10.244.0.34:5432",target_ip="10.244.0.34",target_port="5432",tls="true",server_id="default.dblin.serviceaccount.identity.linkerd.cluster.local",dst_control_plane_ns="linkerd",dst_namespace="dblin",dst_pod="postgres-0",dst_service="mydb-service",dst_serviceaccount="default",dst_statefulset="postgres",dst_zone="",dst_zone_locality="unknown"} 9
tcp_open_connections{direction="outbound",peer="src",target_addr="10.96.158.10:5432",target_ip="10.96.158.10",target_port="5432",tls="no_identity",no_tls_reason="loopback"} 0
tcp_open_connections{direction="outbound",peer="dst",authority="mydb-service.dblin.svc.cluster.local:5432",target_addr="10.244.0.34:5432",target_ip="10.244.0.34",target_port="5432",tls="true",server_id="default.dblin.serviceaccount.identity.linkerd.cluster.local",dst_control_plane_ns="linkerd",dst_namespace="dblin",dst_pod="postgres-0",dst_service="mydb-service",dst_serviceaccount="default",dst_statefulset="postgres",dst_zone="",dst_zone_locality="unknown"} 0

>>>>>>>>>>>>>>>>>>

#this means connecton were p and now its 0, So connection is opened from flask app and is closed that is why it is not showing in the linkered edges via viz tool:
linkerd viz edges -n dblin deployment

##########################
#Work around###############
###########################
#To create a pod which establishes connection and keep it open to myservice

kubectl exec -it debug -n dblin -c psql -- psql -h mydb-service -p 5432 -U postgres -d mydb
#It will open connectionin mydb db, do:
SELECT * FROM sensors;
#no do in another terminal:
linkerd viz edges po -n dblin

<<<<<<<<<<
SRC                           DST                         SRC_NS        DST_NS   SECURED          
debug                         postgres-0                  dblin         dblin    √  
prometheus-6bc6785bff-gbchw   debug                       linkerd-viz   dblin    √ 
>>>>>>>>>>>>

This means there is a connection from debug to postgres-0 pod, as we have initiated an interactive tcp connection 





l viz edges  po  -n dblin
SRC                           DST                         SRC_NS        DST_NS   SECURED          
debug                         postgres-0                  dblin         dblin    √  
prometheus-6bc6785bff-gbchw   debug                       linkerd-viz   dblin    √  
prometheus-6bc6785bff-gbchw   flask-app-d76d9dc58-sck9f   linkerd-viz   dblin    √  
prometheus-6bc6785bff-gbchw   new-postgres-0              linkerd-viz   dblin    √  
prometheus-6bc6785bff-gbchw   postgres-0                  linkerd-viz   dblin    √  

######
#Checking the traffic via top command:
#######

When you make API calls to flaks server either via ingress or via nodeport hyou can do in one bash:
linkerd viz top pod/flask-app-d76d9dc58-sck9f --namespace dblin

Output:
<<<<<<<<<<<<<<
(press q to quit)
(press a/LeftArrowKey to scroll left, d/RightArrowKey to scroll right)

Source                                     Destination                Method      Path               
ingress-nginx-controller-54d9445ccb-wdh7l  flask-app-d76d9dc58-sck9f  POST        /                  
ingress-nginx-controller-54d9445ccb-wdh7l  flask-app-d76d9dc58-sck9f  GET         /static/style.css
ingress-nginx-controller-54d9445ccb-wdh7l  flask-app-d76d9dc58-sck9f  GET         /static/raphael-2.1
ingress-nginx-controller-54d9445ccb-wdh7l  flask-app-d76d9dc58-sck9f  GET         /static/justgage.js
ingress-nginx-controller-54d9445ccb-wdh7l  flask-app-d76d9dc58-sck9f  GET         /plot/temp
10.244.0.1                                 flask-app-d76d9dc58-sck9f  POST        /
10.244.0.1                                 flask-app-d76d9dc58-sck9f  GET         /static/style.css
10.244.0.1                                 flask-app-d76d9dc58-sck9f  GET         /static/raphael-2.1
10.244.0.1                                 flask-app-d76d9dc58-sck9f  GET         /static/justgage.js
10.244.0.1                                 flask-app-d76d9dc58-sck9f  GET


>>>>>>>>>>>>

This shows which traffic was from where which path which methods was accessed


mkdir -p /tmp/n8n
touch /tmp/n8n/last_seen.txt

current_list=$(find /data -type f -exec stat -c "%n %Y" {} \; | sort)
current_hash=$(echo "$current_list" | sha256sum | awk '{print $1}')
last_hash=$(cat /tmp/n8n/last_seen.txt 2>/dev/null)

if [ "$current_hash" != "$last_hash" ]; then
  echo "$current_hash" > /tmp/n8n/last_seen.txt
  echo "new_file_detected=true"
else
  echo "new_file_detected=false"
fi








#!/bin/sh
mkdir -p /tmp/n8n
touch /tmp/n8n/last_seen.txt

latest=$(ls -t /data 2>/dev/null | head -n 1)
last=$(cat /tmp/n8n/last_seen.txt)

if [ "$latest" != "$last" ] && [ -n "$latest" ]; then
  echo "$latest" > /tmp/n8n/last_seen.txt
  echo '{"newFile": true}'
else
  echo '{"newFile": false}'
fi